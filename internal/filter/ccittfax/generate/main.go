// seehuhn.de/go/pdf - a library for reading and writing PDF files
// Copyright (C) 2025  Jochen Voss <voss@seehuhn.de>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "usage: %s [file]\n", os.Args[0])
		flag.PrintDefaults()
	}
	flag.Parse()

	outputFile := "tables.go"
	if flag.NArg() > 0 {
		outputFile = flag.Arg(0)
	}

	if err := run(outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run(outputFile string) error {
	buf := &bytes.Buffer{}
	fmt.Fprintf(buf, "// Code generated by go-pdf/internal/filter/ccittfax/generate/main.go. DO NOT EDIT.\n\n")
	fmt.Fprintf(buf, "package ccittfax\n\n")

	if err := writeConstants(buf); err != nil {
		return err
	}

	// 2D mode codes
	mainTable := make([]decodeNode, 128) // 7-bit table
	fillTable(mainTable, 7, passTable, S_Pass)
	fillTable(mainTable, 7, horizTable, S_Horiz)
	fillTable(mainTable, 7, vertTable, S_Vert)
	fillTable(mainTable, 7, extTable, S_Ext)
	fillTable(mainTable, 7, eolvTable, S_EOL)
	if err := writeTIFFTable(buf, 7, mainTable, "mainTable"); err != nil {
		return err
	}

	// Fill white run-length tables
	whiteTable := make([]decodeNode, 4096) // 12-bit table
	fillTable(whiteTable, 12, makeUpWTable, S_MakeUpW)
	fillTable(whiteTable, 12, makeUpTable, S_MakeUp)
	fillTable(whiteTable, 12, termWTable, S_TermW)
	fillTable(whiteTable, 12, eolhTable, S_EOL)
	if err := writeTIFFTable(buf, 12, whiteTable, "whiteTable"); err != nil {
		return err
	}

	// Fill black run-length tables
	blackTable := make([]decodeNode, 8192) // 13-bit table
	fillTable(blackTable, 13, makeUpBTable, S_MakeUpB)
	fillTable(blackTable, 13, makeUpTable, S_MakeUp)
	fillTable(blackTable, 13, termBTable, S_TermB)
	fillTable(blackTable, 13, eolhTable, S_EOL)
	if err := writeTIFFTable(buf, 13, blackTable, "blackTable"); err != nil {
		return err
	}

	// Write encoding tables for run-length to code conversion
	if err := writeEncodingTable(buf, "whiteTermEncodeTable", termWTable, 0, 1); err != nil {
		return err
	}

	if err := writeEncodingTable(buf, "blackTermEncodeTable", termBTable, 0, 1); err != nil {
		return err
	}

	if err := writeEncodingTable(buf, "whiteMakeupEncodeTable", makeUpWTable, 64, 64); err != nil {
		return err
	}

	if err := writeEncodingTable(buf, "blackMakeupEncodeTable", makeUpBTable, 64, 64); err != nil {
		return err
	}

	if err := writeEncodingTable(buf, "extMakeupEncodeTable", makeUpTable, 1792, 64); err != nil {
		return err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		return err
	}
	return nil
}

// fillTable populates a Huffman decoding table with entries from a protocol table.
// For leaf states (Term, Makeup, EOL), Param is the decoded value.
// For 2D mode states (Pass, Horiz, V0, VR, VL, Ext), Param contains mode-specific data.
func fillTable(table []decodeNode, bits int, protoTable []proto, state state) {
	for _, p := range protoTable {
		width := int(p.width)
		shift := bits - width
		// Calculate the range of table indices this code covers
		a := p.code << shift
		b := a + (1 << shift)

		for code := a; code < b; code++ {
			table[code] = decodeNode{
				State: state,
				Width: uint8(width),
				Param: p.param,
			}
		}
	}
}

type state uint8

const (
	S_Null    state = iota
	S_Pass          // 2D: Pass mode
	S_Horiz         // 2D: Horizontal mode
	S_Vert          // 2D: Vertical mode
	S_Ext           // 2D: Extension code for T.6
	S_TermW         // Leaf: White Terminating code
	S_TermB         // Leaf: Black Terminating code
	S_MakeUpW       // Leaf: White Makeup code
	S_MakeUpB       // Leaf: Black Makeup code
	S_MakeUp        // Leaf: Common Makeup code (for runs > 1792)
	S_EOL           // Leaf: End-Of-Line
)

func (s state) String() string {
	switch s {
	case S_Null:
		return "S_Null"
	case S_Pass:
		return "S_Pass"
	case S_Horiz:
		return "S_Horiz"
	case S_Vert:
		return "S_Vert"
	case S_Ext:
		return "S_Ext"
	case S_TermW:
		return "S_TermW"
	case S_TermB:
		return "S_TermB"
	case S_MakeUpW:
		return "S_MakeUpW"
	case S_MakeUpB:
		return "S_MakeUpB"
	case S_MakeUp:
		return "S_MakeUp"
	case S_EOL:
		return "S_EOL"
	default:
		return fmt.Sprintf("state(%d)", s)
	}
}

type decodeNode struct {
	State state
	Width uint8
	Param uint16
}

func writeTIFFTable(w io.Writer, bits int, table []decodeNode, name string) error {
	fmt.Fprintf(w, "var %s = []decodeNode{\n", name)

	for i, p := range table {
		if p.State != S_Null {
			// Show the bit pattern this entry matches, with '_' separating the matched prefix
			code := uint32(i)
			comment := fmt.Sprintf("%0*b", bits, code)
			if len(comment) > int(p.Width) {
				comment = comment[:int(p.Width)] + "_" + comment[int(p.Width):]
			}
			fmt.Fprintf(w, "\tdecodeNode{State: %s, Width: %d, Param: %d}, // %s\n",
				p.State, p.Width, p.Param, comment)
		} else {
			fmt.Fprintln(w, "\tdecodeNode{},")
		}
	}

	fmt.Fprint(w, "}\n\n")
	return nil
}

func writeEncodingTable(w io.Writer, name string, protoTable []proto, start, step uint16) error {
	// Find the size needed for the encoding table
	maxEntry := 0
	for _, p := range protoTable {
		idx := (p.param - start) / step
		if int(idx) > maxEntry {
			maxEntry = int(idx)
		}
	}

	table := make([]encodeNode, maxEntry+1)

	for _, p := range protoTable {
		idx := (p.param - start) / step
		table[idx] = encodeNode{
			Code:  uint32(p.code),
			Width: p.width,
		}
	}

	fmt.Fprintf(w, "var %s = []encodeNode{\n", name)

	for i, node := range table {
		if node.Width > 0 {
			runLength := int(start) + i*int(step)
			fmt.Fprintf(w, "\tencodeNode{Code: 0b%0*b, Width: %d}, // run length %d\n",
				node.Width, node.Code, node.Width, runLength)
		} else {
			fmt.Fprintln(w, "\tencodeNode{},")
		}
	}

	fmt.Fprint(w, "}\n\n")
	return nil
}

func writeConstants(w io.Writer) error {
	fmt.Fprintln(w, "// State constants for decodeNode.State")
	fmt.Fprintln(w, "const (")
	fmt.Fprintf(w, "\tS_Null     state = %d\n", S_Null)
	fmt.Fprintf(w, "\tS_Pass     state = %d // 2D: Pass mode\n", S_Pass)
	fmt.Fprintf(w, "\tS_Horiz    state = %d // 2D: Horizontal mode\n", S_Horiz)
	fmt.Fprintf(w, "\tS_Vert state = %d // 2D: Vertical mode V(0)\n", S_Vert)
	fmt.Fprintf(w, "\tS_Ext      state = %d // 2D: Extension code for T.6\n", S_Ext)
	fmt.Fprintf(w, "\tS_TermW    state = %d // Leaf: White Terminating code\n", S_TermW)
	fmt.Fprintf(w, "\tS_TermB    state = %d // Leaf: Black Terminating code\n", S_TermB)
	fmt.Fprintf(w, "\tS_MakeUpW  state = %d // Leaf: White Makeup code\n", S_MakeUpW)
	fmt.Fprintf(w, "\tS_MakeUpB  state = %d // Leaf: Black Makeup code\n", S_MakeUpB)
	fmt.Fprintf(w, "\tS_MakeUp   state = %d // Leaf: Common Makeup code\n", S_MakeUp)
	fmt.Fprintf(w, "\tS_EOL      state = %d // Leaf: End-Of-Line\n", S_EOL)
	fmt.Fprint(w, ")\n\n")
	return nil
}

type encodeNode struct {
	Code  uint32
	Width uint8
}
