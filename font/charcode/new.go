// seehuhn.de/go/pdf - a library for reading and writing PDF files
// Copyright (C) 2024  Jochen Voss <voss@seehuhn.de>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package charcode

import (
	"errors"
	"slices"

	"golang.org/x/exp/maps"
)

// A Codec efficiently converts between sequences of bytes and uint32 character codes.
type Codec struct {
	// nodes is a linearised lookup tree.  The root of the nodes is at index 0.
	nodes []linearizedNode
}

// linearizedNode represents a node in the lookup tree of a [Codec].
type linearizedNode struct {
	// The current input byte is compared to bound.  If the input byte is less
	// than or equal to bound, the input byte is consumed and the node
	// described by child becomes the new node.  Otherwise, the lookup
	// continues with the next node in Decoder.tree.
	bound byte

	// Child determines the next node, in case the input byte is less than or
	// equal to bound:
	//
	// - If child equals 0, the consumed byte
	//   is the last byte of a valid character code and the lookup stops.
	// - If child equals 0xFFFF - k, for kâˆˆ{0,1,2,3}, the input starts
	//   with an invalid character code.  The lookup stops and
	//   an additional k bytes must be consumed to continue.
	// - For all other cases, the child node is the index of the next node in
	//   Decoder.tree.
	child uint16
}

// These constants represent special values of the child field in a [node].
const (
	validLeaf       uint16 = 0x0000
	invalidConsume3 uint16 = 0xfffc
	invalidConsume2 uint16 = 0xfffd
	invalidConsume1 uint16 = 0xfffe
	invalidConsume0 uint16 = 0xffff
)

// NewCodec returns a new Decoder for the given code space range.
// If the code space range is invalid, an error is returned.
func NewCodec(ranges CodeSpaceRange) (*Codec, error) {
	for _, r := range ranges {
		if len(r.Low) != len(r.High) || len(r.Low) == 0 || len(r.Low) > 4 {
			return nil, errInvalidCodeSpaceRange
		}
	}

	tree, _, err := newTree(ranges, 0)
	if err != nil {
		return nil, err
	}

	c := &Codec{
		nodes: linearize(tree),
	}
	return c, nil
}

// Decode decodes the first character code of an input byte sequence.
// The method returns the character code, the number of bytes consumed,
// and whether the character code is valid.
//
// The returned code contains the consumed bytes, with the first byte
// in the least significant position.
//
// At the end of input, (0, 0, false) is returned.
//
// The return value consumed is always less than or equal to the length of s.
// If the length of s is non-zero, consumed is greater than zero.
func (c *Codec) Decode(s []byte) (code uint32, consumed int, valid bool) {
	var cur uint16
	for {
		if len(s) == 0 {
			return
		}
		var b byte
		b, s = s[0], s[1:]

		// Since codes are at most 4 bytes long, consumed can only be 0, 1, 2,
		// or 3 at this point.
		code |= uint32(b) << (8 * consumed)
		consumed++

		// Use a linear scan to find the correct child node.  If performance
		// ever becomes an issue, the code could be restructured to use a
		// binary tree here.
		var node linearizedNode
		for {
			node = c.nodes[cur]
			if b <= node.bound {
				break
			}
			cur++
		}

		next := node.child
		switch next {
		case validLeaf:
			valid = true
			return
		case invalidConsume3:
			if len(s) > 0 {
				code |= uint32(s[0]) << (8 * consumed)
				s = s[1:]
				consumed++
			}
			fallthrough
		case invalidConsume2:
			if len(s) > 0 {
				code |= uint32(s[0]) << (8 * consumed)
				s = s[1:]
				consumed++
			}
			fallthrough
		case invalidConsume1:
			if len(s) > 0 {
				code |= uint32(s[0]) << (8 * consumed)
				consumed++
			}
			fallthrough
		case invalidConsume0:
			return
		default:
			cur = next
		}
	}
}

// AppendCode converts an uint32 code to bytes and appends the bytes to the
// given slice.
func (c *Codec) AppendCode(s []byte, code uint32) []byte {
	// For trees generated by [newTree], cur increases with any iteration
	// of the following loop.  Thus, the loop will always terminate.

	cur := uint16(0) // root
	for {
		b := byte(code)
		s = append(s, b)
		code >>= 8

		var node linearizedNode
		for {
			node = c.nodes[cur]
			if b <= node.bound {
				break
			}
			cur++
		}

		next := node.child
		switch next {
		case validLeaf:
			return s
		case invalidConsume3:
			s = append(s, byte(code))
			code >>= 8
			fallthrough
		case invalidConsume2:
			s = append(s, byte(code))
			code >>= 8
			fallthrough
		case invalidConsume1:
			s = append(s, byte(code))
			fallthrough
		case invalidConsume0:
			return s
		default:
			cur = next
		}
	}
}

// CodeSpaceRange returns a CodeSpaceRange which contains exactly the same codes
// as the one used to create the Codec.
func (c *Codec) CodeSpaceRange() CodeSpaceRange {
	return c.walk(nil, 0, nil, nil)
}

// walk traverses a sub-tree, constructing a CodeSpaceRange by recursively
// visiting nodes and appending ranges defined by the low and high byte slices.
//
// Parameters:
// - csr: slice to append the ranges to
// - cur: the root of the sub-tree
// - low: current lower bound of the range
// - high: current upper bound of the range
//
// Returns:
// - CodeSpaceRange: The extended CodeSpaceRange after traversing the sub-tree.
func (c *Codec) walk(csr CodeSpaceRange, cur uint16, low, high []byte) CodeSpaceRange {
	var nextLow byte
	for {
		nextHigh := c.nodes[cur].bound
		low2 := append(low, nextLow)
		high2 := append(high, nextHigh)
		switch c.nodes[cur].child {
		case validLeaf:
			r := Range{Low: clone(low2), High: clone(high2)}
			if k := canMerge(csr, r); k >= 0 {
				csr[len(csr)-1].High[k] = high2[k]
			} else {
				csr = append(csr, r)
			}
		case invalidConsume0, invalidConsume1, invalidConsume2, invalidConsume3:
			// pass
		default:
			csr = c.walk(csr, c.nodes[cur].child, low2, high2)
		}

		if nextHigh == 0xFF {
			return csr
		}
		nextLow = nextHigh + 1
		cur++
	}
}

func canMerge(csr CodeSpaceRange, r Range) int {
	if len(csr) == 0 {
		return -1
	}

	last := csr[len(csr)-1]
	if len(last.Low) != len(r.Low) {
		return -1
	}

	// We can merge the ranges, the ranges for one byte are adjacent,
	// and the ranges for all other bytes are equal.

	adjIdx := -1
	for i := 0; i < len(r.Low)-1; i++ {
		isEqual := last.Low[i] == r.Low[i] && last.High[i] == r.High[i]
		if isEqual {
			continue
		}

		isAdjacent := int(last.High[i])+1 == int(r.Low[i])
		if !isAdjacent || adjIdx != -1 {
			return -1
		}
		adjIdx = i
	}
	return adjIdx
}

func clone(b []byte) []byte {
	res := make([]byte, len(b))
	copy(res, b)
	return res
}

// tree is an intermediate representation of the lookup tree.
// For use in a [Codec] it is linearized into a slice of [linearizedNode].
//
// The map keys are the highest input byte values which correspond to a child node.
type tree map[byte]*treeNode

type treeNode struct {
	// Desc is a string representation of the effect of the sub-tree rooted at
	// the node.
	//
	// For leaf nodes with valid==false, this is {0x00, consume}.
	//
	// For all other nodes this is {0x01, child1, high1, child2, high2, ..., 0x02},
	desc []byte

	// children contains the child nodes of this node.
	children tree

	// For leaf nodes with valid==false, this is the number of addional bytes
	// to consume.
	consume int
}

const (
	descInvalid byte = iota
	descValidBegin
	descValidEnd
)

// newTree returns a new lookup tree for the given code space range.
func newTree(ranges CodeSpaceRange, depth int) (tree, []byte, error) {
	t := make(tree)

	breaks := make(map[int]bool)
	breaks[0] = true
	breaks[256] = true
	for _, r := range ranges {
		breaks[int(r.Low[depth])] = true
		breaks[int(r.High[depth])+1] = true
	}
	bSlice := maps.Keys(breaks)
	slices.Sort(bSlice)

	var childRanges CodeSpaceRange

	desc := []byte{descValidBegin}
	for j := 0; j < len(bSlice)-1; j++ {
		low := byte(bSlice[j])
		high := byte(bSlice[j+1] - 1)

		// find all elements of ii which overlap [low, high]
		childRanges = childRanges[:0]
		for _, r := range ranges {
			if r.Low[depth] <= high && r.High[depth] >= low {
				childRanges = append(childRanges, r)
			}
		}

		// At this point we have consumed the input bytes up to depth,
		// and we know that any of the childRanges still apply.

		if len(childRanges) == 0 {
			// There are no ranges which overlap [low, high],
			// and thus byte values in [low, high] are invalid here.

			// Section 9.7.6.3 (Handling undefined characters) of ISO
			// 32000-2:2020 specifies the following: In case of an invalid
			// code, the number of input bytes consumed is the length of the
			// shortest code which contains the longest possible prefix of the
			// given code.

			minLength := minLength(ranges)
			alreadyConsumed := depth + 1

			t[high] = &treeNode{
				desc:    []byte{descInvalid, byte(minLength - alreadyConsumed)},
				consume: minLength - alreadyConsumed,
			}
			continue
		}

		numLeaves := 0
		for _, r := range childRanges {
			if len(r.Low) == depth+1 {
				numLeaves++
			}
		}
		var node *treeNode
		switch numLeaves {
		case len(childRanges):
			// All ranges end with this byte, so this is a leaf.
			node = &treeNode{
				desc: []byte{descValidBegin, descValidEnd},
			}
		case 0:
			// All ranges have more bytes, so we use a sub-tree to
			// decide which range to use, based on the following bytes.
			cc, dd, err := newTree(childRanges, depth+1)
			if err != nil {
				return nil, nil, err
			}
			node = &treeNode{
				desc:     dd,
				children: cc,
			}
		default:
			// Some ranges end with this byte, while other ranges allow for
			// more bytes.  This is an error, since we cannot decide which
			// range to use.  (No code may be a prefix of another code.)
			return nil, nil, errInvalidCodeSpaceRange
		}

		t[high] = node
		desc = append(desc, node.desc...)
		desc = append(desc, high)
	}
	desc = append(desc, descValidEnd)

	return t, desc, nil
}

func minLength(csr CodeSpaceRange) int {
	if len(csr) == 0 {
		// In order to avoid infinite loops in the decoder, we always consume
		// at least one byte.
		return 1
	}

	min := len(csr[0].Low)
	for _, r := range csr[1:] {
		if l := len(r.Low); l < min {
			min = l
		}
	}
	return min
}

func linearize(t tree) []linearizedNode {
	l := newLinearizer()
	l.AppendNodes(t)
	return l.nodes
}

type linearizer struct {
	nodes []linearizedNode
	done  map[string]uint16
}

func newLinearizer() *linearizer {
	done := make(map[string]uint16)

	// register the predefined values for the child field
	done[string([]byte{descValidBegin, descValidEnd})] = validLeaf
	done[string([]byte{descInvalid, 0x03})] = invalidConsume3
	done[string([]byte{descInvalid, 0x02})] = invalidConsume2
	done[string([]byte{descInvalid, 0x01})] = invalidConsume1
	done[string([]byte{descInvalid, 0x00})] = invalidConsume0

	return &linearizer{
		done: done,
	}
}

func (l *linearizer) AppendNodes(t tree) uint16 {
	bb := maps.Keys(t)
	slices.Sort(bb)

	// reserve space for the child nodes
	base := len(l.nodes)
	for _, high := range bb {
		l.nodes = append(l.nodes, linearizedNode{bound: high})
	}

	for i, high := range bb {
		childNode := t[high]

		idx, ok := l.done[string(childNode.desc)]
		if ok {
			l.nodes[base+i].child = idx
			continue
		}

		childPos := l.AppendNodes(t[high].children)
		l.nodes[base+i].child = childPos
		l.done[string(childNode.desc)] = childPos

		// Here we verify the invariant that child links always point to
		// nodes which are later in the slice.  This ensures that the
		// loop in [Decoder.AppendCode] always terminates.
		if int(childPos) <= base+i {
			panic("unreachable")
		}
	}

	return uint16(base)
}

var errInvalidCodeSpaceRange = errors.New("invalid code space range")
