package main

import (
	"bytes"
	"go/format"
	"os"
	"text/template"

	"seehuhn.de/go/pdf/font/standard"
)

func main() {
	outName := "builtin.go"
	err := Generate(outName)
	if err != nil {
		panic(err)
	}
}

type Data map[string]*fontMetrics

type fontMetrics struct {
	Widths map[string]float64
}

func Generate(fname string) error {
	data, err := getData()
	if err != nil {
		return err
	}

	// Parse the "out.html" template file.
	tmpl := template.Must(template.New("out").Parse(outTmpl))

	// Execute the template with the data.
	buf := &bytes.Buffer{}
	err = tmpl.Execute(buf, data)
	if err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	err = os.WriteFile(fname, formatted, 0644)
	if err != nil {
		return err
	}

	return nil
}

func getData() (Data, error) {
	data := make(Data)
	for _, G := range standard.All {
		err := getFontData(data, G)
		if err != nil {
			return nil, err
		}
	}
	return data, nil

}

func getFontData(data Data, G standard.Font) error {
	F, err := G.New(nil)
	if err != nil {
		return err
	}

	widths := make(map[string]float64)
	for name, info := range F.Metrics.Glyphs {
		widths[name] = info.WidthX
	}
	info := &fontMetrics{Widths: widths}
	data[F.FontName] = info
	return nil
}

const outTmpl = `// Code generated by font-metrics-generator; DO NOT EDIT.

package type1

type fontMetrics struct {
	Widths map[string]float64
}

var builtinMetrics = map[string]*fontMetrics{
{{- range $fontName, $metrics := . }}
    "{{ $fontName }}": {
        Widths: map[string]float64{
        {{- range $char, $width := $metrics.Widths }}
            "{{ $char }}": {{ $width }},
        {{- end }}
        },
    },
{{- end }}
}
`
